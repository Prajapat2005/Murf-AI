/*   const recognitionRef = useRef<any>(null)
  const synthRef = useRef<SpeechSynthesis | null>(null)

  useEffect(() => {
    if (typeof window !== "undefined") {
      synthRef.current = window.speechSynthesis
    }
  }, [])

  const startRecording = () => {
    if (!("webkitSpeechRecognition" in window) && !("SpeechRecognition" in window)) {
      alert("Speech recognition not supported in this browser")
      return
    }

    const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition
    recognitionRef.current = new SpeechRecognition()

    recognitionRef.current.continuous = true
    recognitionRef.current.interimResults = true
    recognitionRef.current.lang = fromLanguage

    recognitionRef.current.onstart = () => {
      setIsRecording(true)
      setOriginalText("")
      setTranslatedText("")
    }

    recognitionRef.current.onresult = (event: any) => {
      let finalTranscript = ""

      for (let i = event.resultIndex; i < event.results.length; i++) {
        if (event.results[i].isFinal) {
          finalTranscript += event.results[i][0].transcript
        }
      }

      if (finalTranscript) {
        setOriginalText(finalTranscript)
        translateText(finalTranscript)
      }
    }

    recognitionRef.current.onerror = (event: any) => {
      console.error("Speech recognition error:", event.error)
      setIsRecording(false)
    }

    recognitionRef.current.onend = () => {
      setIsRecording(false)
    }

    recognitionRef.current.start()
  }

  const translateText = async (text: string) => {
    if (!text.trim()) return

    setIsTranslating(true)

    try {
      const response = await fetch("/api/translate", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          text,
          from: fromLanguage,
          to: toLanguage,
        }),
      })

      if (response.ok) {
        const data = await response.json()
        setTranslatedText(data.translatedText)
      } else {
        setTranslatedText(`[Translated from ${fromLanguage} to ${toLanguage}]: ${text}`)
      }
    } catch (error) {
      console.error("Translation error:", error)
      setTranslatedText(`[Translated from ${fromLanguage} to ${toLanguage}]: ${text}`)
    } finally {
      setIsTranslating(false)
    }
  }

  const playTranslation = () => {
    if (!synthRef.current || !translatedText) return

    setIsPlaying(true)
    const utterance = new SpeechSynthesisUtterance(translatedText)
    utterance.lang = toLanguage
    utterance.rate = 0.8

    if (selectedVoice !== "default" && synthRef.current.getVoices().length > 0) {
      const availableVoices = synthRef.current.getVoices()
      const selectedVoiceData = voices.find((v) => v.id === selectedVoice)

      if (selectedVoiceData) {
        const matchingVoice = availableVoices.find(
          (voice) =>
            voice.lang.startsWith(toLanguage) &&
            (selectedVoiceData.gender === "male"
              ? voice.name.toLowerCase().includes("male") ||
              voice.name.toLowerCase().includes("david") ||
              voice.name.toLowerCase().includes("james")
              : selectedVoiceData.gender === "female"
                ? voice.name.toLowerCase().includes("female") ||
                voice.name.toLowerCase().includes("sarah") ||
                voice.name.toLowerCase().includes("emma")
                : true),
        )

        if (matchingVoice) {
          utterance.voice = matchingVoice
        }
      }
    }

    utterance.onend = () => {
      setIsPlaying(false)
    }

    utterance.onerror = () => {
      setIsPlaying(false)
    }

    synthRef.current.speak(utterance)
  } */